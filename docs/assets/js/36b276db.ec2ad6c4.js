"use strict";(self.webpackChunkstreamsheets=self.webpackChunkstreamsheets||[]).push([[96505],{3905:(e,t,s)=>{s.d(t,{Zo:()=>d,kt:()=>u});var o=s(67294);function n(e,t,s){return t in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}function a(e,t){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),s.push.apply(s,o)}return s}function i(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{};t%2?a(Object(s),!0).forEach((function(t){n(e,t,s[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):a(Object(s)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))}))}return e}function l(e,t){if(null==e)return{};var s,o,n=function(e,t){if(null==e)return{};var s,o,n={},a=Object.keys(e);for(o=0;o<a.length;o++)s=a[o],t.indexOf(s)>=0||(n[s]=e[s]);return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)s=a[o],t.indexOf(s)>=0||Object.prototype.propertyIsEnumerable.call(e,s)&&(n[s]=e[s])}return n}var r=o.createContext({}),c=function(e){var t=o.useContext(r),s=t;return e&&(s="function"==typeof e?e(t):i(i({},t),e)),s},d=function(e){var t=c(e.components);return o.createElement(r.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var s=e.components,n=e.mdxType,a=e.originalType,r=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=c(s),u=n,m=h["".concat(r,".").concat(u)]||h[u]||p[u]||a;return s?o.createElement(m,i(i({ref:t},d),{},{components:s})):o.createElement(m,i({ref:t},d))}));function u(e,t){var s=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=s.length,i=new Array(a);i[0]=h;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var c=2;c<a;c++)i[c]=s[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,s)}h.displayName="MDXCreateElement"},56393:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>b,contentTitle:()=>u,default:()=>f,frontMatter:()=>h,metadata:()=>m,toc:()=>k});var o=s(3905),n=Object.defineProperty,a=Object.defineProperties,i=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,r=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,d=(e,t,s)=>t in e?n(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,p=(e,t)=>{for(var s in t||(t={}))r.call(t,s)&&d(e,s,t[s]);if(l)for(var s of l(t))c.call(t,s)&&d(e,s,t[s]);return e};const h={id:"mqtt-glossary",title:"MQTT Glossary",sidebar_label:"Glossary"},u=void 0,m={unversionedId:"MQTT/mqtt-glossary",id:"MQTT/mqtt-glossary",title:"MQTT Glossary",description:"Below a list of often used terms, when working with MQTT architectures.",source:"@site/mosquitto/MQTT/glossary.md",sourceDirName:"MQTT",slug:"/MQTT/mqtt-glossary",permalink:"/documentation-staging/mosquitto/next/MQTT/mqtt-glossary",draft:!1,tags:[],version:"current",frontMatter:{id:"mqtt-glossary",title:"MQTT Glossary",sidebar_label:"Glossary"},sidebar:"someSidebar",previous:{title:"Introduction",permalink:"/documentation-staging/mosquitto/next/MQTT/mqtt-introduction"},next:{title:"Release Notes",permalink:"/documentation-staging/mosquitto/next/broker/release-notes"}},b={},k=[{value:"Broker",id:"broker",level:2},{value:"Client",id:"client",level:2},{value:"Cluster",id:"cluster",level:2},{value:"Dynamic Security",id:"dynamic-security",level:2},{value:"Topic",id:"topic",level:2},{value:"Acknowledgement",id:"acknowledgement",level:4},{value:"Clean Session",id:"clean-session",level:4},{value:"Clean Start",id:"clean-start",level:4},{value:"Client ID",id:"client-id",level:4},{value:"CONNACK",id:"connack",level:4},{value:"CONNECT",id:"connect",level:4},{value:"DUP",id:"dup",level:4},{value:"Flag",id:"flag",level:4},{value:"IP",id:"ip",level:4},{value:"Keep Alive",id:"keep-alive",level:4},{value:"Last Will",id:"last-will",level:4},{value:"Message",id:"message",level:4},{value:"MQTT",id:"mqtt",level:4},{value:"MQTT v.3.1.1",id:"mqtt-v311",level:4},{value:"MQTT v.5.0",id:"mqtt-v50",level:4},{value:"Packet",id:"packet",level:4},{value:"Packet ID",id:"packet-id",level:4},{value:"Password",id:"password",level:4},{value:"Payload",id:"payload",level:4},{value:"Persistent Session",id:"persistent-session",level:4},{value:"PINGREQ",id:"pingreq",level:4},{value:"PINGRESP",id:"pingresp",level:4},{value:"Pub / Sub",id:"pub--sub",level:4},{value:"PUBACK",id:"puback",level:4},{value:"PUBCOMP",id:"pubcomp",level:4},{value:"PUBLISH",id:"publish",level:4},{value:"Publisher",id:"publisher",level:4},{value:"PUBREC",id:"pubrec",level:4},{value:"PUBREL",id:"pubrel",level:4},{value:"Quality of Service QoS",id:"quality-of-service-qos",level:4},{value:"QoS 0",id:"qos-0",level:4},{value:"QoS 1",id:"qos-1",level:4},{value:"QoS 2",id:"qos-2",level:4},{value:"Queue",id:"queue",level:4},{value:"Retained Message",id:"retained-message",level:4},{value:"Return Code",id:"return-code",level:4},{value:"Session",id:"session",level:4},{value:"Session Expiry Interval",id:"session-expiry-interval",level:4},{value:"SUBSCRIBE",id:"subscribe",level:4},{value:"Subscriber",id:"subscriber",level:4},{value:"Subscription",id:"subscription",level:4},{value:"TCP",id:"tcp",level:4},{value:"TLS",id:"tls",level:4},{value:"UNSUBSCRIBE",id:"unsubscribe",level:4}],v={toc:k};function f(e){var t,s=e,{components:n}=s,d=((e,t)=>{var s={};for(var o in e)r.call(e,o)&&t.indexOf(o)<0&&(s[o]=e[o]);if(null!=e&&l)for(var o of l(e))t.indexOf(o)<0&&c.call(e,o)&&(s[o]=e[o]);return s})(s,["components"]);return(0,o.kt)("wrapper",(t=p(p({},v),d),a(t,i({components:n,mdxType:"MDXLayout"}))),(0,o.kt)("p",null,"Below a list of often used terms, when working with MQTT architectures."),(0,o.kt)("h2",p({},{id:"broker"}),"Broker"),(0,o.kt)("p",null,"The Broker is the server that communicates with all clients to manage the message or\npacket transfer using the MQTT Protocol. The broker receives all messages published from connected clients\nand coordinates the message transfer to subscribing clients based on topics. The broker also ensures security issues.\nMessages are to some extent cached on the broker to be resent, if a connection is temporarily lost or a message\ndid not reach the client (depending on QoS)"),(0,o.kt)("h2",p({},{id:"client"}),"Client"),(0,o.kt)("p",null,"A client can be any device that can run a MQTT library and is able to connect to a broker. Clients communicate with the\nbroker via topics."),(0,o.kt)("h2",p({},{id:"cluster"}),"Cluster"),(0,o.kt)("p",null,"A cluster provides the ability to run a cluster of broker nodes with a single leader and\nmultiple followers, so that broker availability can be ensured even if a single node becomes unavailable through fault\nor for an upgrade. This document describes the recommended cluster architecture and how to configure the cluster for\nfirst use, and in the future."),(0,o.kt)("p",null,"The Mosquitto cluster comprises at least three nodes. A single node is available for use by MQTT clients at once, the\nother nodes operate as fail-over nodes. The cluster expects a minimum of two nodes to be available at once, to provide a\nleader and a fallback node. If the state of the cluster fails so that only a single node is available, clients will be\nunable to connect until the cluster is in a stable state again."),(0,o.kt)("p",null,"TODO Link"),(0,o.kt)("h2",p({},{id:"dynamic-security"}),"Dynamic Security"),(0,o.kt)("p",null,"The Dynamic Security plugin for Eclipse Mosquitto provides role based\nauthentication and access control features that can updated while the broker\nis running, using a special topic based API."),(0,o.kt)("p",null,"It is supported since Eclipse Mosquitto 2.0, and should be available in all\ninstallations, but will not be activated by default."),(0,o.kt)("h2",p({},{id:"topic"}),"Topic"),(0,o.kt)("p",null,"Messages in MQTT are published to topics. A topic is a string that that acts as an identifier for messages to be\npublished to or subscribed from. There is no need to configure a topic, publishing on it automatically creates a topic,\nyou can\nsubscribe on."),(0,o.kt)("p",null,"Topics are treated as a hierarchy, using a slash (/) as a separator. This allows an arrangement of common themes to be\ncreated, much in the same way as a file system. This way you can group or organize your data to be published."),(0,o.kt)("p",null,"Valid examples for grouped topics could be:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Company/Location/MachineA/Speed"),(0,o.kt)("li",{parentName:"ul"},"Company/Location/MachineB/Speed"),(0,o.kt)("li",{parentName:"ul"},"Company/Location/MachineC/Speed"),(0,o.kt)("li",{parentName:"ul"},"Company/Location/MachineC/Temp")),(0,o.kt)("p",null,'Topics can contain spaces and are case-sensitive. Topics must use UTF8 coding. Zero length topic levels are valid, which\ncan lead to some slightly non-obvious behaviour. For example, a topic of "\na//topic" would correctly match against a subscription of "a/+/topic". Likewise, zero length topic levels can exist at\nboth the beginning and the end of a topic string, so "/a/topic" would match against a subscription of "+/a/topic", "#"\nor "/#", and a topic "a/topic/" would match against a subscription of "a/topic/+" or "a/topic/#".'),(0,o.kt)("p",null,"Clients can receive messages by creating subscriptions. A subscription may be to an explicit topic, in which case only\nmessages to that topic will be received, or it may include wildcards. Two wildcards are available, + or #."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"'+' can be used as a wildcard for a single level of hierarchy. For the above topics using Company/Location/+/Speed\nwould subscribe to all machines messages related to Speed."),(0,o.kt)("li",{parentName:"ul"},"'#' can be used as a wildcard for all remaining levels of a hierarchy. For the above topics using\nCompany/Location/MachineC/# would subscribe to all messages for MachineC.")),(0,o.kt)("p",null,"TODO Link"),(0,o.kt)("h4",p({},{id:"acknowledgement"}),"Acknowledgement"),(0,o.kt)("p",null,"There are various acknowledgements that are used within MQTT:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"SUBACK"),(0,o.kt)("li",{parentName:"ul"},"CONNACK"),(0,o.kt)("li",{parentName:"ul"},"PUBACK / PUBREC / PUBREL")),(0,o.kt)("h4",p({},{id:"clean-session"}),"Clean Session"),(0,o.kt)("p",null,"This parameter shows if a client wants to establish a persistent session with a broker or not. Therefore, the\ncleanSession parameter can have two values: \u201ctrue\u201d (Client doesn\u2019t want to establish a persistent session. In addition,\nall previous persistent sessions are dismissed.) or \u201cfalse\u201d(Client wants to establish a persistent session.)"),(0,o.kt)("h4",p({},{id:"clean-start"}),"Clean Start"),(0,o.kt)("p",null,"cleanStart = 0\nIn this case the server resumes communication with the client based on the state of the current session (the session is\nidentified by the clientId).\nIf there is no earlier session, the broker must create a new session.\nIn case of a connection disconnectiong, the broker must store:\nWhether the session exists. Even though a topic has no subscriptions and therefore the session would be without real\nuse.\nAll subscriptions.\nAll QoS1 or QoS2 messages that haven't been confirmed by the client yet.\ncleanStart = 1\nIn this case the broker discards any previous sessions and opens a new one."),(0,o.kt)("h4",p({},{id:"client-id"}),"Client ID"),(0,o.kt)("p",null,"Most used for cleanSession. In case you have set CleanFlag=false and reconnected with the same clientId, the broker\nremembers the topics you have subscribed to."),(0,o.kt)("h4",p({},{id:"connack"}),"CONNACK"),(0,o.kt)("p",null,"The broker in return responds by sending a so-called CONNACK packet (Acknowledge connection request) and a status code.\nIf the clean session value in a client\u2019s CONNECT message is \u201ctrue,\u201d then the session present value in the CONNACK\nresponse will be \u201cfalse.\u201d It means that a client and broker should establish a new session and, at the same time,\ndiscard any existing one. After the CONNECT and CONNACK packet is exchanged, the connection is enabled.\n","![mqttProtocol]"," (./_images//CONNACK.png)\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#broker-client-connection"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#broker-client-connection")),(0,o.kt)("h4",p({},{id:"connect"}),"CONNECT"),(0,o.kt)("p",null,"An MQTT broker always connects clients who want to share and clients who want to receive data.\n","![mqttProtocol]"," (./_images//CONNECT.png)\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#broker-client-connection"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#broker-client-connection")),(0,o.kt)("h4",p({},{id:"dup"}),"DUP"),(0,o.kt)("p",null,"A dupFlag indicates the duplicate of a message.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt#dupflag"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt#dupflag")),(0,o.kt)("h4",p({},{id:"flag"}),"Flag"),(0,o.kt)("p",null,"There is only the DUP flag available within MQTT."),(0,o.kt)("h4",p({},{id:"ip"}),"IP"),(0,o.kt)("p",null,"The Internet Protocol (IP) is a network protocol that is widespread in computer networks and represents the basis of the\nInternet due to its function. The IP is the implementation of the Internet layer of the TCP/IP model.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/security#tcpip-is-not-safe-on-its-own"}),"https://docs.cedalo.com/mosquitto/2.1/security#tcpip-is-not-safe-on-its-own")),(0,o.kt)("h4",p({},{id:"keep-alive"}),"Keep Alive"),(0,o.kt)("p",null,"The MQTT keepAlive parameter identifies the maximum interval in seconds (e.g., 120, as I show in this article\u2019s example)\nwhen a client maintains the MQTT connection but without communication (sending an MQTT packet). After the specified\nkeepAlive parameter period is over, a client sends a PING request (PINGREQ), and a broker has to respond with a PING\nResponse (PINGRESP). If no response follows the PING request, the client can assume the connection has disconnected.\nAlso, the broker is waiting for the PING request. The broker must expect a PINGREQ and wait for another half of the set\nin the keepAlive parameter time, but then disconnect the connection for good.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt#keepalive"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt#keepalive")),(0,o.kt)("h4",p({},{id:"last-will"}),"Last Will"),(0,o.kt)("p",null,"The lastWill message is sent by the broker on behalf of the client when a disconnect occurs without a DISCONNECT packet\nbefore the actual break-off.\nLink-> ",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#lastwill"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#lastwill")),(0,o.kt)("h4",p({},{id:"message"}),"Message"),(0,o.kt)("p",null,"The actual content of a message is the content of a payload. MQTT is not limited by its payload format. It delivers what\nthe publisher is sending. This could be a value, string, JSON file, or even content of a jpg or an mp3 file. Up to\n256MB. The payload does not encrypt the content. The broker simply delivers what the publisher inserts into the payload.\nLink-> ",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#payload"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#payload")),(0,o.kt)("h4",p({},{id:"mqtt"}),"MQTT"),(0,o.kt)("p",null,"MQTT = \u201cMQ Telemetry Transport\u201d. The setup consists of two basic concepts: PUBLISH / SUBSCRIBE and CLIENT / BROKER. And\nthree basic functionalities: CONNECT, PUBLISH, SUBSCRIBE\n-> ",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/")),(0,o.kt)("h4",p({},{id:"mqtt-v311"}),"MQTT v.3.1.1"),(0,o.kt)("p",null,"Most MQTT-related devices support v.3.1.1 whilst v.5.0 not.\n",(0,o.kt)("a",p({parentName:"p"},{href:"http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html"}),"http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html")),(0,o.kt)("h4",p({},{id:"mqtt-v50"}),"MQTT v.5.0"),(0,o.kt)("p",null,"The MQTT version 5.0 is the next development step in the evolution of MQTT. Especially interesting is the changes made\nto the cleanSession. Have a look here. ",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt#connect"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt#connect"),"\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/supported-mqtt-versions/#v50"}),"https://docs.cedalo.com/mosquitto/2.1/supported-mqtt-versions/#v50")),(0,o.kt)("h4",p({},{id:"packet"}),"Packet"),(0,o.kt)("p",null,'There is no definition of when a delivery is called a packet or message. Cedalo is using the term "packet" for any of\nthe commands, and "message" for publishing or subscribing messages. All packets must pass the broker.'),(0,o.kt)("h4",p({},{id:"packet-id"}),"Packet ID"),(0,o.kt)("p",null,"Unique packet identifier the broker uses to identify the packet when needed.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt#packetid-1"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt#packetid-1")),(0,o.kt)("h4",p({},{id:"password"}),"Password"),(0,o.kt)("p",null,"MQTT can forward and handle username and password within a sent packet. It's important that whenever a packet is not\nencrypted or hashed (either by implementation or TSL), the password is sent as plain text.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#usernamepassword"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#usernamepassword")),(0,o.kt)("h4",p({},{id:"payload"}),"Payload"),(0,o.kt)("p",null,"MQTT is not limited by its payload format. It delivers what the publisher is sending. The actual content of a message is\nthe content of a payload.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt#payload"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt#payload")),(0,o.kt)("h4",p({},{id:"persistent-session"}),"Persistent Session"),(0,o.kt)("p",null,"The Persistent session is active when the cleanSession flag is set to false. An active MQTT persistent session (with the\ncleanSession having the \u201cfalse\u201d value) is activated whenever the client disconnects ungracefully. All information that\nthe client did not receive from the broker since the last active connection will be preserved on the broker and\ndelivered to the client once the connection is restored. The broker resumes the client in the existing session if the\nclientId is the same as the disconnected client. A client will not have to resubscribe to all topics again.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt#persistent-sessions"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt#persistent-sessions")),(0,o.kt)("h4",p({},{id:"pingreq"}),"PINGREQ"),(0,o.kt)("p",null,"No matter who is not answering or sending the PINGREQ or PINGRESP within the specific time interval plus another half of\nthe very same interval, the broker or client must disconnect. When this happens, the broker sends the lastWill and\ntestament message. If the client has created one. Within the interval, it's ok that the client and broker do not\ntransmit messages. In fact, after this interval, the client must send a so-called PING Request packet (PINGREQ).\n","![mqttProtocol]"," (./_images//PINGREQ.png)\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#keepalive"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#keepalive")),(0,o.kt)("h4",p({},{id:"pingresp"}),"PINGRESP"),(0,o.kt)("p",null,'The broker must respond with a PING Response (PINGRESP). If the connection is out of sync, and a participant is not\nresponding - called a "half-open connection", keepAlive takes action.\n',"![mqttProtocol]"," (./_images//PINGRESP.png)\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#keepalive"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#keepalive")),(0,o.kt)("h4",p({},{id:"pub--sub"}),"Pub / Sub"),(0,o.kt)("p",null,"The PUBLISH/SUBSCRIBE model connects client that want to exchange information/data/messages.\nThe model consists of the client-server model. Any client communicates with an endpoint via the broker. Before a client\nwants to publish messages it first has to set up a connection with the broker. Also, a subscribing client has to do the\nsame. Therefore, the broker can decouple the publisher and subscriber.\nLink-> ",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#central-hub"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#central-hub")),(0,o.kt)("h4",p({},{id:"puback"}),"PUBACK"),(0,o.kt)("p",null,"The broker must acknowledge each SUBSCRIBE packet. Therefore the broker sends a SUBACK packet (subscribe acknowledge) to\nthe client.\n","![mqttProtocol]"," (./_images//PUBACK.png)\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#subscriptions"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#subscriptions")),(0,o.kt)("h4",p({},{id:"pubcomp"}),"PUBCOMP"),(0,o.kt)("p",null,"To discard all stored states and answers a so-called PUBCOMP packet (Publish complete) is sent. That's the end of the\nQoS2 order of events.\n","![mqttProtocol]"," (./_images//PUBCOMP.png)\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/quality-of-service/#qos2---exactly-once"}),"https://docs.cedalo.com/mosquitto/2.1/quality-of-service/#qos2---exactly-once")),(0,o.kt)("h4",p({},{id:"publish"}),"PUBLISH"),(0,o.kt)("p",null,"The PUBLISH packet consists of details that indicate to the broker what to do.\nRead more about these here. ",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#packetid"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#packetid"),"\n","![mqttProtocol]"," (./_images//PUBLISH.png)\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#mqtt-pubsub-model"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#mqtt-pubsub-model")),(0,o.kt)("h4",p({},{id:"publisher"}),"Publisher"),(0,o.kt)("p",null,"Either one publisher publishes messages to multiple Subscribers. Or multiple publishers publish messages to just one\nsubscriber. Or any combination of multiple publishers/subscribers. Any publisher can only be identified when information\nabout the publisher is included in the topic or payload.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt#client-server-model"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt#client-server-model")),(0,o.kt)("h4",p({},{id:"pubrec"}),"PUBREC"),(0,o.kt)("p",null,"A PUBREC Packet is a response to a PUBLISH Packet with QoS 2. It is the second packet of the QoS 2 protocol exchange.\n","![mqttProtocol]"," (./_images//PUBREC.png)\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/quality-of-service/#qos2---exactly-once"}),"https://docs.cedalo.com/mosquitto/2.1/quality-of-service/#qos2---exactly-once")),(0,o.kt)("h4",p({},{id:"pubrel"}),"PUBREL"),(0,o.kt)("p",null,"A PUBREL is another packet the broker sends after receiving the PUBREC packet. This packet must be responded to with a\nPUBCOMP packet.\n","![mqttProtocol]"," (./_images//PUBREL.png)\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/quality-of-service/#qos2---exactly-once"}),"https://docs.cedalo.com/mosquitto/2.1/quality-of-service/#qos2---exactly-once")),(0,o.kt)("h4",p({},{id:"quality-of-service-qos"}),"Quality of Service QoS"),(0,o.kt)("p",null,"The QoS (Quality of Service) defines a certain level of service that enables the publisher to make sure that the\ncertainty and quantity of a subscriber receiving a sent message equal the importance to receive the message at all, plus\nwhether to receive the message only once. Also, a subscriber can set a QoS, defining the importance to receive every\nmessage, and whether to accept one message multiple times or not. There are three levels available.\n-> ",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#qos"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#qos")),(0,o.kt)("h4",p({},{id:"qos-0"}),"QoS 0"),(0,o.kt)("p",null,'The broker/client is delivering the message only once, without confirmation. There is no guarantee that the message sent\nhas been sent to the subscriber. The recipient on the other end does not acknowledge the receipt. Neither is the\nacknowledgment stored. The QoS0 - level is often referred to be the "fire and forget"-level.\n',(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#qos-0---at-most-once"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#qos-0---at-most-once")),(0,o.kt)("h4",p({},{id:"qos-1"}),"QoS 1"),(0,o.kt)("p",null,"Level 1 QoS guarantees the delivery of a message to the receiver at least once.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#qos-1---at-least-once"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#qos-1---at-least-once")),(0,o.kt)("h4",p({},{id:"qos-2"}),"QoS 2"),(0,o.kt)("p",null,"QoS level 2 guarantees each message is received exactly once.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt/#qos-2---exactly-once"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt/#qos-2---exactly-once")),(0,o.kt)("h4",p({},{id:"queue"}),"Queue"),(0,o.kt)("p",null,"When a persistent session is active, the broker must queue the missed messages. Whenever a persistent session is created\nby the client, and the broker already queued messages of an earlier persistent session, the broker delivers the queued\nmessages using the same old session.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt#persistent-sessions"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt#persistent-sessions")),(0,o.kt)("h4",p({},{id:"retained-message"}),"Retained Message"),(0,o.kt)("p",null,"A retained message safes the last known value of the topic. It's only possible to save up to one retained message, equal\nto one retained value. The retainFlag identifies a message to be a retained message. To identify the message itself the\npacketId is used.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt#retainflag"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt#retainflag")),(0,o.kt)("h4",p({},{id:"return-code"}),"Return Code"),(0,o.kt)("p",null,"The return code is used within a SUBACK packet. The broker sends one return code for each topic/QoS-pair that it\nreceives in the SUBSCRIBE packet. The return codes can be:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"0 - Success-Maximum QoS0"),(0,o.kt)("li",{parentName:"ul"},"1 - Success-Maximum QoS1"),(0,o.kt)("li",{parentName:"ul"},"2 - Success-Maximum QoS2"),(0,o.kt)("li",{parentName:"ul"},"128 - Failure")),(0,o.kt)("h4",p({},{id:"session"}),"Session"),(0,o.kt)("p",null,"If a client connects to the broker a session is started. If a client connects to the broker and another client session\nalready exists with the clientId that the new client has chosen, the old session will be kicked out and taken over."),(0,o.kt)("h4",p({},{id:"session-expiry-interval"}),"Session Expiry Interval"),(0,o.kt)("p",null,"sessionExpiryInterval:"),(0,o.kt)("p",null,"Whenever a session ExpiryInterval is set (e.g. 60) a cleanStart is automatically set to \u201c0\u201d.\nWith a sessionExpiryInterval active the sessionState will be saved immediately after the keepAlive runs out (e.g. 120\nplus half of the keepAlive - that would be 60 seconds in this case).The sessionState is safed for the amount of time\nset (in this case 60 seconds).\nsessionExpiryInterval is solving the problem that you don\u2019t need to send anther CONNECT packet including\ncleanSession=1 (MQTT v.3.1.1) to discard the session after set it retained."),(0,o.kt)("h4",p({},{id:"subscribe"}),"SUBSCRIBE"),(0,o.kt)("p",null,"To receive messages on topics of interest, the client sends a SUBSCRIBE packet to the broker.\n","![mqttProtocol]"," (./_images//SUBSCRIBE.png)\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/mqtt#subscribe"}),"https://docs.cedalo.com/mosquitto/2.1/mqtt#subscribe")),(0,o.kt)("h4",p({},{id:"subscriber"}),"Subscriber"),(0,o.kt)("p",null,"Direct contact between subscriber and publisher is never able. Only the broker enables transmitting messages. Also, the\nsubscribing client only has one duty. To subscribe to the topic it wants to receive messages from. The subscriber-only\nknows about the existence of the publisher as the client subscribes to the published topics.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/subscribing"}),"https://docs.cedalo.com/mosquitto/2.1/subscribing")),(0,o.kt)("h4",p({},{id:"subscription"}),"Subscription"),(0,o.kt)("p",null,"A subscription consists of a packetId. And the subscriptions the subscriber wants to subscribe to. Each subscription\nconsists of a topic and a QoS level. When subscriptions overlap, the broker delivers the message that has the highest\nQoS level for the specific topic.\n","![mqttProtocol]"," (./_images//SUBSCRIBE.png)\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/broker-introduction#subscribe"}),"https://docs.cedalo.com/mosquitto/2.1/broker-introduction#subscribe")),(0,o.kt)("h4",p({},{id:"tcp"}),"TCP"),(0,o.kt)("p",null,"TCP is embedding TLS (Transport Layer Security). Allowing MQTT packets to be transmitted via encrypted pipes. TLS\nprotects all parts of an MQTT packet, not only the payload.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/security#authorization"}),"https://docs.cedalo.com/mosquitto/2.1/security#authorization")),(0,o.kt)("h4",p({},{id:"tls"}),"TLS"),(0,o.kt)("p",null,"Using Transport Layer Security (TLS) provides a secured communication channel a client and a server can use to connect.\nTLS is a cryptographic protocol, that uses a handshake mechanism to create a secure connection between client and\nserver.\n",(0,o.kt)("a",p({parentName:"p"},{href:"https://docs.cedalo.com/mosquitto/2.1/security#server-side-tls"}),"https://docs.cedalo.com/mosquitto/2.1/security#server-side-tls")),(0,o.kt)("h4",p({},{id:"unsubscribe"}),"UNSUBSCRIBE"),(0,o.kt)("p",null,"A client can always UNSUBSCRIBE from a topic. The UNSUBSCRIBE packet includes the packetId and list of topics the\nsubscriber wants to unsubscribe from.\n","![mqttProtocol]"," (./_images//UNSUBSCRIBE.png)"))}f.isMDXComponent=!0}}]);