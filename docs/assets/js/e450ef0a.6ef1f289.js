"use strict";(self.webpackChunkstreamsheets=self.webpackChunkstreamsheets||[]).push([[65403],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>c});var i=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),p=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=p(e.components);return i.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(t),c=a,f=u["".concat(s,".").concat(c)]||u[c]||m[c]||o;return t?i.createElement(f,r(r({ref:n},d),{},{components:t})):i.createElement(f,r({ref:n},d))}));function c(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,r=new Array(o);r[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var p=2;p<o;p++)r[p]=t[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},84508:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>c,default:()=>b,frontMatter:()=>u,metadata:()=>f,toc:()=>g});var i=t(3905),a=Object.defineProperty,o=Object.defineProperties,r=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable,d=(e,n,t)=>n in e?a(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,m=(e,n)=>{for(var t in n||(n={}))s.call(n,t)&&d(e,t,n[t]);if(l)for(var t of l(n))p.call(n,t)&&d(e,t,n[t]);return e};const u={id:"influxdb-bridge",title:"InfluxDB Bridge",sidebar_label:"InfluxDB Bridge"},c="InfluxDB Bridge Plugin",f={unversionedId:"bridges/influxdb-bridge",id:"bridges/influxdb-bridge",title:"InfluxDB Bridge",description:"Introduction",source:"@site/mosquitto/bridges/influxdb-bridge.md",sourceDirName:"bridges",slug:"/bridges/influxdb-bridge",permalink:"/documentation-staging/mosquitto/next/bridges/influxdb-bridge",draft:!1,tags:[],version:"current",frontMatter:{id:"influxdb-bridge",title:"InfluxDB Bridge",sidebar_label:"InfluxDB Bridge"},sidebar:"someSidebar",previous:{title:"HTTP Bridge",permalink:"/documentation-staging/mosquitto/next/bridges/http-bridge"},next:{title:"Kafka Bridge",permalink:"/documentation-staging/mosquitto/next/bridges/kafka-bridge"}},h={},g=[{value:"Introduction",id:"introduction",level:2},{value:"Plugin activation",id:"plugin-activation",level:2},{value:"Control topic",id:"control-topic",level:2},{value:"Config format",id:"config-format",level:2},{value:"Mapping MQTT packets to InfluxDB",id:"mapping-mqtt-packets-to-influxdb",level:2},{value:"Data type casting",id:"data-type-casting",level:2},{value:"Line Protocol",id:"line-protocol",level:2},{value:"Extractor options",id:"extractor-options",level:2},{value:"Choosing InfluxDB version",id:"choosing-influxdb-version",level:2},{value:"SSL connection options",id:"ssl-connection-options",level:2},{value:"Compression",id:"compression",level:2},{value:"Configuration example",id:"configuration-example",level:2},{value:"Error handling",id:"error-handling",level:2},{value:"Debugging",id:"debugging",level:2},{value:"Notes on data insertions and data format",id:"notes-on-data-insertions-and-data-format",level:2},{value:"Buffering",id:"buffering",level:2},{value:"Retry queue",id:"retry-queue",level:2},{value:"JSON schema",id:"json-schema",level:2}],k={toc:g};function b(e){var n,t=e,{components:a}=t,d=((e,n)=>{var t={};for(var i in e)s.call(e,i)&&n.indexOf(i)<0&&(t[i]=e[i]);if(null!=e&&l)for(var i of l(e))n.indexOf(i)<0&&p.call(e,i)&&(t[i]=e[i]);return t})(t,["components"]);return(0,i.kt)("wrapper",(n=m(m({},k),d),o(n,r({components:a,mdxType:"MDXLayout"}))),(0,i.kt)("h1",m({},{id:"influxdb-bridge-plugin"}),"InfluxDB Bridge Plugin"),(0,i.kt)("h2",m({},{id:"introduction"}),"Introduction"),(0,i.kt)("p",null,"The InfluxDB Bridge plugin can be used to forward data published to the Mosquitto broker to InfluxDB time-series databases.\nThe plugin can handle multiple database connections. For each connection, a mapping between certain MQTT topics and InfluxDB measurements can be defined (see ",(0,i.kt)("a",m({parentName:"p"},{href:"#configuration-example"}),"example configuration"),")."),(0,i.kt)("p",null,"The list of currently supported InfluxDB versions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InfluxDB v1.x")," (using the ",(0,i.kt)("inlineCode",{parentName:"li"},"influx/v1")," driver)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InfluxDB v2.x")," (using the ",(0,i.kt)("inlineCode",{parentName:"li"},"influx/v2")," driver)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InfluxDB v3.x")," (using the ",(0,i.kt)("inlineCode",{parentName:"li"},"influx/v2")," driver (same as ",(0,i.kt)("inlineCode",{parentName:"li"},"InfluxDB v2.x"),"))")),(0,i.kt)("p",null,"InfluxDB Bridge supports both basic (username, password) authentication for v1 and token-based authentication for v2."),(0,i.kt)("p",null,"The plugin manages incoming MQTT messages in a buffer to perform batching and improve performance when writing to InfluxDB. The size properties of the buffer can be controlled via the configuration in the ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," section, with ",(0,i.kt)("inlineCode",{parentName:"p"},"bufferSize")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"timeoutMs")," (refer to ",(0,i.kt)("a",m({parentName:"p"},{href:"#config-format"}),"config format"),")."),(0,i.kt)("h2",m({},{id:"plugin-activation"}),"Plugin activation"),(0,i.kt)("p",null,"To enable the InfluxDB Bridge plugin in the broker, add the following to the ",(0,i.kt)("inlineCode",{parentName:"p"},"mosquitto.conf")," file:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{}),"plugin /usr/lib/cedalo_influxdb_bridge.so\n\npersistence_location /mosquitto/data\n")),(0,i.kt)("p",null,"This is an example configuration snippet, which applies to the docker container setup. For installation not running in a container, the above configuration needs to be adjusted accordingly (namely the location of ",(0,i.kt)("inlineCode",{parentName:"p"},"cedalo_influxdb_bridge.so")," dynamic library and ",(0,i.kt)("inlineCode",{parentName:"p"},"persistence_location")," may differ)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"persistence_location")," is used as the search path for the plugin's config file in the context of a single node broker. The file must be called ",(0,i.kt)("inlineCode",{parentName:"p"},"Influxdb-Bridge.json"),". This file must be created to allow the plugin to start, but it may be left empty. The ownership of this file should be given to the ",(0,i.kt)("inlineCode",{parentName:"p"},"mosquitto")," user.\nIn the context of an HA cluster, configuration is fully managed by the Cedalo Platform or manually via a respective control topic (see the section below)."),(0,i.kt)("p",null,"In addition to modifying ",(0,i.kt)("inlineCode",{parentName:"p"},"mosquitto.conf"),", ensure that you have the appropriate license to use the plugin."),(0,i.kt)("h2",m({},{id:"control-topic"}),"Control topic"),(0,i.kt)("p",null,"The plugin can be controlled using the ",(0,i.kt)("inlineCode",{parentName:"p"},"$CONTROL/cedalo/influxdb-bridge/v1")," control topic. The matching response topic is ",(0,i.kt)("inlineCode",{parentName:"p"},"$CONTROL/cedalo/influxdb-bridge/v1/response"),".\nThe commands that are currently supported are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"updateConfig")," - updates the bridge's configuration."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getConfig")," - fetches the configuration currently used by the bridge."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getStatus")," - fetches status information of the bridge."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"getSchema")," - fetches schema information about the JSON schema of the configuration (as defined by IETF standard).")),(0,i.kt)("p",null,"The examples of the control request are presented below, however, more detailed information including response formats can be found in the Async API documentation."),(0,i.kt)("p",null,"To update bridge's configuration a message in the following format should be sent to the control topic:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    "commands": [\n        {\n            "command": "updateConfig",\n            "correlationData": "1234",\n            "configChange": <Config JSON object>\n        }\n    ]\n}\n')),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    "commands": [\n        {\n            "command": "updateConfig",\n            "label": "db/qa/test",\n            "temperature": 12,\n            "correlationData": "1234",\n            "configChange": {\n                "version": "1",\n                "connections": [\n                    {\n                        "name": "influxdb-connection-1",\n                        "connection": {\n                            "driver": "influxdbv2",\n                            "hostname": "influxdbv2",\n                            "port": 8086,\n                            "database": "fishbucket",\n                            "organization": "marines",\n                            "debug": true,\n                            "credentials": {\n                                "token": "<your token here. In case of influxdbv1 driver you will have to provide username and password fields instead>"\n                            }\n                        },\n                        "options": {\n                            "bufferSize": 10000,\n                            "batchSize": 1000,\n                            "timeoutMs": 4000,\n                            "queueMaxSize": 10000,\n                            "maxRetries": 15,\n                            "retryDelayMs": 1000\n                        },\n                        "topicMappings": [\n                            {\n                                "name": "topic-mapping-to-influxdb-1",\n                                "schemaMapping": "schema-mapping-1",\n                                "target": "fish_metrics",\n                                "mqttTopics": [\n                                    "db/qa/#",\n                                    "db2/dev/influx"\n                                ]\n                            },\n                            {\n                                "name": "topic-mapping-to-influxdb-2",\n                                "schemaMapping": "schema-mapping-1",\n                                "target": "fish_metrics2",\n                                "mqttTopics": [\n                                    "db/qa/#",\n                                    "db2/dev/influx2"\n                                ]\n                            }\n                        ]\n                    }\n                ],\n                "schemaMappings": [\n                    {\n                        "name": "schema-mapping-1",\n                        "mapping": [\n                            {\n                                "source": "[payload]",\n                                "target": "",\n                                "targetType": "lineProtocol"\n                            }\n                        ]\n                    }\n                ]\n            }\n        }\n    ]\n}\n')),(0,i.kt)("p",null,'Remember the correlation data should be a unique random string. This is used to correlate requests to the matching responses arriving at the response topic. If you are performing a few manual requests "by hand" you may omit it. However, for broker management applications and scripts it is highly recommended to make use of this field to avoid confusing responses.'),(0,i.kt)("p",null,"Example of the ",(0,i.kt)("inlineCode",{parentName:"p"},"getConfig")," command:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    "commands": [\n        {\n            "command": "getConfig",\n            "correlationData": "1234"\n        }\n    ]\n}\n')),(0,i.kt)("p",null,"Example of ",(0,i.kt)("inlineCode",{parentName:"p"},"getStatus"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    "commands": [\n        {\n            "command": "getStatus",\n            "correlationData": "1234"\n        }\n    ]\n}\n')),(0,i.kt)("p",null,"This command will return data about the availability of each connection, the number of buffers and queues, all the dropped as well as currently queued messages.\nAs the plugin creates a queue and buffer per InfluxDB measurement the information about queues and buffers will be presented as an array of numbers with each element corresponding to a separate queue/buffer."),(0,i.kt)("p",null,"Example of ",(0,i.kt)("inlineCode",{parentName:"p"},"getSchema"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    "commands": [\n        {\n            "command": "getSchema",\n            "correlationData": "1234"\n        }\n    ]\n}\n')),(0,i.kt)("h2",m({},{id:"config-format"}),"Config format"),(0,i.kt)("p",null,"The configuration is managed by the control topic with the latest update being stored to disk with a filename of ",(0,i.kt)("inlineCode",{parentName:"p"},"Influxdb-Bridge.json")," under the persistence location (as defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"mosquitto.conf"),")."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that in the single node setting, the plugin will not be able to start unless the ",(0,i.kt)("inlineCode",{parentName:"p"},"Influxdb-Bridge.json")," file exists under the persistence location. When first starting the plugin this file should be created but may be left empty. The owner of this file should be the ",(0,i.kt)("inlineCode",{parentName:"p"},"mosquitto")," user.")),(0,i.kt)("p",null,'The configuration of the plugin is a JSON object consisting of an array of connection objects as well as an array of so-called "schema mappings". Each connection object defines its own InfluxDB connection and MQTT topics to listen to. It also references a mapping of the MQTT message properties to InfluxDB fields and tags (or an entire line protocol record if the MQTT message is a line protocol string). Such mappings are called schema mappings and are described in a different array within the same file under ',(0,i.kt)("inlineCode",{parentName:"p"},"schemaMappings")," field. This is to allow multiple InfluxDB connections to reuse the same mappings."),(0,i.kt)("p",null,"The fields of the configuration object are described below. To see an example of the config file refer to the ",(0,i.kt)("a",m({parentName:"p"},{href:"#configuration-example"}),"configuration example section"),".\nRefer to the ",(0,i.kt)("a",m({parentName:"p"},{href:"#json-schema"}),"configuration schema")),(0,i.kt)("p",null,"The following fields of the config are mandatory:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"connections")," (path: ",(0,i.kt)("inlineCode",{parentName:"p"},"$.connections"),"): ",(0,i.kt)("br",null)," An array of InfluxDB connection objects. Apart from database connection settings, each connection object also contains MQTT topic mapping information (type: ",(0,i.kt)("inlineCode",{parentName:"p"},"array"),")."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].name"),"): ",(0,i.kt)("br",null)," Unique identifier of the InfluxDB Bridge connection object. A convenience name for the database connection used in the plugin's logs (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"connection")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection"),"): ",(0,i.kt)("br",null)," Object holding the actual database connection information (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),").",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"driver")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.driver"),"): ",(0,i.kt)("br",null)," Name of the driver to be used with the database connection. (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),", one of: ",(0,i.kt)("inlineCode",{parentName:"li"},"influxdbv1"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"influxdbv2"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hostname")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.hostname"),"): ",(0,i.kt)("br",null)," Hostname or IP address of the InfluxDB server (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"port")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.port"),"): ",(0,i.kt)("br",null)," Port that the InfluxDB server listens for client connections on (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"database")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.database"),"): ",(0,i.kt)("br",null)," Name of the database for InfluxDB v1 or bucket for InfluxDB v2 to connect to (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"credentials")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials"),"): ",(0,i.kt)("br",null)," Object holding authentication information. (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),")",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"For InfluxDB v1:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"username")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials.username"),"): ",(0,i.kt)("br",null)," Username used for authenticating against the database (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"password")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials.password"),"): ",(0,i.kt)("br",null)," Password of the user used for authenticating against the database. (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")"))),(0,i.kt)("li",{parentName:"ul"},"For InfluxDB v2:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"token")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.credentials.token"),"): ",(0,i.kt)("br",null)," Authentication token for InfluxDB v2 connection (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"organization")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.organization"),"): ",(0,i.kt)("br",null)," Organization that a bucket belongs to in InfluxDB v2. This field is only required by InfluxDB v2 itself. But it's not a required field in the JSON schema of the plugin (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"topicMappings")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings"),"): ",(0,i.kt)("br",null)," List of mappings specifying a mapping between MQTT topics and InfluxDB measurements to forward data to (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"array")," of type ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),").",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.name"),"): ",(0,i.kt)("br",null)," Unique identifier of the current topic mapping (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.target"),"): ",(0,i.kt)("br",null)," Name of the InfluxDB measurement into which MQTT data needs to be inserted. If your MQTT messages are line protocol strings already, this field should be set to an empty string (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mqttTopics")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.mqttTopics"),"): ",(0,i.kt)("br",null)," An array of MQTT topics that should be forwarded to InfluxDB. MQTT wildcards (",(0,i.kt)("inlineCode",{parentName:"li"},"+")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"#"),") can also be used (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"array")," of type ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"schemaMapping")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.schemaMapping"),"): ",(0,i.kt)("br",null)," Name of a particular schema mapping from ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings")," array to be used as a mapping between ",(0,i.kt)("inlineCode",{parentName:"li"},"target")," measurement and ",(0,i.kt)("inlineCode",{parentName:"li"},"mqttTopics"),"."))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"schemaMappings")," (path: ",(0,i.kt)("inlineCode",{parentName:"p"},"$.schemaMappings"),"): ",(0,i.kt)("br",null)," An array of schema mappings. Each element of the array specifies a mapping between MQTT message properties and InfluxDB fields and tags (type: ",(0,i.kt)("inlineCode",{parentName:"p"},"array")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"object"),")."))),(0,i.kt)("p",null,"Optional fields:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"connections")," (path: ",(0,i.kt)("inlineCode",{parentName:"p"},"$.connections"),")"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"connection")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection"),")",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"compression")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.compression"),"): ",(0,i.kt)("br",null)," Properties related to data compression for InfluxDB v2. Not applicable for v1 (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),")",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"enable")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.compression.enable"),"): ",(0,i.kt)("br",null)," Whether to compress data before sending to InfluxDB. Less bandwidth required but inflicts more strain on the server (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),")"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ssl")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl"),"): ",(0,i.kt)("br",null)," SSL options. SSL connection with the database will not be established if this option is not defined (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),")",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rejectUnauthorized")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl.rejectUnauthorized"),"): ",(0,i.kt)("br",null)," Whether to refuse unauthorized certificates from the InfluxDB server. (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"caPath")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl.caPath"),"): ",(0,i.kt)("br",null)," Path to CA that signed InfluxDB server certificate (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ca")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.ssl.ca"),"): ",(0,i.kt)("br",null)," String with CA that signed InfluxDB server certificate. Use either this property or ",(0,i.kt)("inlineCode",{parentName:"li"},"caPath")," (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"debug")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.debug"),"): ",(0,i.kt)("br",null)," Whether to log debug information about queries performed by the plugin. This option is currently not in use by the plugin. It's reserved for the future versions (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"lazyConnect")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].connection.lazyConnect"),"): ",(0,i.kt)("br",null)," Whether to allow the plugin to continue if the connection to the database cannot be established (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),")."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"options")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].options"),"): ",(0,i.kt)("br",null)," Object holding additional plugin settings (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),").",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"bufferSize")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].options.bufferSize"),"): ",(0,i.kt)("br",null)," Defines the size of the buffer, which is used to batch multiple MQTT messages together before inserting them into InfluxDB. For more information, see ",(0,i.kt)("a",m({parentName:"li"},{href:"#buffering"}),"the section on buffering")," (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"1000"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"timeoutMs")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].options.timeoutMs"),"): ",(0,i.kt)("br",null)," Interval in milliseconds after which buffer is forcefully released if it is not empty. In other words, it specifies a maximum latency of the buffer release (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"5000"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"queueMaxSize")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].options.queueMaxSize"),"): ",(0,i.kt)("br",null)," Defines the max size of a retry queue used in case a database insert fails due to connection problems. If set to ",(0,i.kt)("inlineCode",{parentName:"li"},"-1"),", the size of the queue is not limited. For more information see ",(0,i.kt)("a",m({parentName:"li"},{href:"#retry-queue"}),"the section on retry queue")," (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"-1"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"maxRetries")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].options.maxRetries"),"): ",(0,i.kt)("br",null)," Defines a number of retries to be performed by a retry queue before dropping the message. For more information, see ",(0,i.kt)("a",m({parentName:"li"},{href:"#retry-queue"}),"the section on retry queue")," (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"10"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"retryDelayMs")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].options.retryDelayMs"),"): ",(0,i.kt)("br",null)," Defines a delay in milliseconds between the retry attempts of the queue. For more information, see ",(0,i.kt)("a",m({parentName:"li"},{href:"#retry-queue"}),"the section on retry queue")," (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"1000"),")."))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"schemaMappings")," (path: ",(0,i.kt)("inlineCode",{parentName:"p"},"$.schemaMappings"),"): ",(0,i.kt)("br",null)," An array of schema mappings. Each element of the array specifies a mapping between MQTT message properties and InfluxDB fields and tags (type: ",(0,i.kt)("inlineCode",{parentName:"p"},"array")," of type ",(0,i.kt)("inlineCode",{parentName:"p"},"object"),")."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].name"),"): ",(0,i.kt)("br",null)," Unique identifier of the current schema mapping. This name is matched against ",(0,i.kt)("inlineCode",{parentName:"li"},"$.connections[].topicMappings.schemaMapping")," to determine which schema mapping to use for particular measurement (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mapping")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping"),"): ",(0,i.kt)("br",null)," An array holding source-to-target mapper object with information about which properties or metadata to pick out from your MQTT messages as well as which InfluxDB fields or tags those properties should be inserted into (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"array")," of type ",(0,i.kt)("inlineCode",{parentName:"li"},"object"),").",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"source")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].source"),"): ",(0,i.kt)("br",null)," Source of the data to be inserted. This can be a property of the MQTT message payload (in case the payload is a JSON object) or some metadata property (e.g. client_id, timestamp, etc). This field follows a particular unpacking syntax. For more information, see ",(0,i.kt)("a",m({parentName:"li"},{href:"#mapping-mqtt-packets-to-influxdb"}),"below")," (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"target")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].target"),"): ",(0,i.kt)("br",null)," InfluxDB target field or tag name into which data from the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," field will be inserted. For the MQTT messages which are already line protocol strings this field should be an empty string (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"targetType")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].targetType"),"): ",(0,i.kt)("br",null)," Whether the target is a tag, field, or a line protocol string (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),", one of: ",(0,i.kt)("inlineCode",{parentName:"li"},"tag"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"field"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"lineProtocol"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"type")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].type"),"): ",(0,i.kt)("br",null)," Optional type casting of the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," field before it gets inserted into InfluxDB. See more information about typecasting ",(0,i.kt)("a",m({parentName:"li"},{href:"#data-type-casting"}),"here")," (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"options")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options"),"): ",(0,i.kt)("br",null)," Object holding information about additional transformations to be performed on ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," before it is inserted into InfluxDB.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isConst"),"(path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.isConst"),"): ",(0,i.kt)("br",null)," Used to indicate that the field in ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," is a constant that should be inserted into InfluxDB as is without trying to unpack it. This is relevant in case the ",(0,i.kt)("inlineCode",{parentName:"li"},"source")," field is a string that follows the unpacking syntax but should be treated as a constant. Otherwise (i.e. for constants that don't follow the unpacking syntax), this field is not required and therefore can be omitted or only added for clarity and additional context (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replace")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.replace"),"): ",(0,i.kt)("br",null)," Specifies an array of two strings. Replaces all occurrences of the first string with the second one before inserting the data into the database (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"array")," consisting of two elements of type ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replaceNullWith")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.replaceNullWith"),"): ",(0,i.kt)("br",null)," Specifies a value that null values on the source will be replaced with (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"any"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replaceUndefinedWith")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.replaceUndefinedWith"),"): ",(0,i.kt)("br",null)," In case that a property specified in source is missing on the MQTT message, it will be replaced with the value specified in this option (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"any"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"format")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.format"),"): ",(0,i.kt)("br",null)," Used when casting into datetime datatype (i.e. strings representing date and time). Specifies a datetime format string that values from source are formatted as. See ",(0,i.kt)("a",m({parentName:"li"},{href:"https://date-fns.org/v3.3.1/docs/format"}),"format string documentation")," for more information on available format strings. Defaults to ",(0,i.kt)("inlineCode",{parentName:"li"},"yyyy-MM-ddTHH:mm:ss.sssZ")," (with an optional timezone information). However, by default if an integer value representing a unix timestamp in milliseconds is encountered in source, it will also be accepted and appropriately converted to the datetime datatype (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dbFormat")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.dbFormat"),"): ",(0,i.kt)("br",null)," Used when casting into datetime datatype. Specifies a format string that datetime values should be converted to before they are inserted into the table (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replaceDelimiter")," (path: ",(0,i.kt)("inlineCode",{parentName:"li"},"$.schemaMappings[].mapping[].options.replaceDelimiter"),"): ",(0,i.kt)("br",null)," Used when casting into datetime datatype. The format of the datetime values inserted into the database will typically be an ISO format as in the following example: 2017-01-29T14:07:00. InfluxDB can understand and parse this format but if you would like to change the delimiter to something else like a space, you can still do it with this option. For more complex changes use the ",(0,i.kt)("inlineCode",{parentName:"li"},"dbFormat")," field (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),").")))))))),(0,i.kt)("h2",m({},{id:"mapping-mqtt-packets-to-influxdb"}),"Mapping MQTT packets to InfluxDB"),(0,i.kt)("p",null,"The plugin configuration specifies the mapping between MQTT packets and InfluxDB fields/tags in the ",(0,i.kt)("inlineCode",{parentName:"p"},"schemaMappings")," field. Elements of the ",(0,i.kt)("inlineCode",{parentName:"p"},"schemaMappings")," array must have unique names that will be matched against the ",(0,i.kt)("inlineCode",{parentName:"p"},"schemaMapping")," field of the respective connection object."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"mapping")," specifies an array of extractor objects (you may also see them being referred to as selectors in other documentation on bridges) between sources and targets. The ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," field represents the source of the data. It comes from the MQTT message or its metadata. The ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," field is the name of the field or tag that ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," will be inserted into in InfluxDB. ",(0,i.kt)("inlineCode",{parentName:"p"},"targetType")," specifies whether the target is a field or tag in InfluxDB, or a line protocol string."),(0,i.kt)("p",null,"To be more precise, the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," field can be a constant, a path to a particular metadata property of an MQTT message, or a data property within its payload. The latter is relevant for JSON MQTT payloads: in case the MQTT payload is a JSON, the path to some data property of such payload can be specified as a source."),(0,i.kt)("p",null,"Below are some examples with clarifications to put the above-mentioned into context:"),(0,i.kt)("p",null,"It is possible to unpack MQTT payload in case it is a JSON and extract (pick out) certain properties from it. This can be achieved by specifying a JSON path to such property in the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," field. However, the properties in this path should be separated not by dots, but rather by square brackets (e.g.: not ",(0,i.kt)("inlineCode",{parentName:"p"},"payload.property1.innerProperty")," but ",(0,i.kt)("inlineCode",{parentName:"p"},"[payload][property1][innerProperty]"),")."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that currently the only supported characters for the JSON payload properties are ",(0,i.kt)("inlineCode",{parentName:"p"},"[a-zA-Z0-9_-]")," (alphanumeric characters as well as ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," (underscore) and ",(0,i.kt)("inlineCode",{parentName:"p"},"-")," (dash))")),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][temperature]",\n            "target": "temp",\n            "targetType": "field"\n        }\n    ],\n    ...\n}\n')),(0,i.kt)("p",null,"In the above example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"temperature")," property from the payload is selected as a field named ",(0,i.kt)("inlineCode",{parentName:"p"},"temp")," in InfluxDB."),(0,i.kt)("p",null,"This means that if the MQTT payload looks like below:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    "temperature": 21.5,\n    "humidity": 45,\n    "status": "normal"\n}\n')),(0,i.kt)("p",null,"then the value ",(0,i.kt)("inlineCode",{parentName:"p"},"21.5")," will be inserted as a field called ",(0,i.kt)("inlineCode",{parentName:"p"},"temp")," in the InfluxDB measurement."),(0,i.kt)("p",null,"Another example:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][sensor][id]",\n            "target": "sensorId",\n            "targetType": "tag"\n        }\n    ],\n    ...\n}\n')),(0,i.kt)("p",null,"The extractor object above expects an MQTT message payload to be in JSON format. It extracts a property ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," from the ",(0,i.kt)("inlineCode",{parentName:"p"},"sensor")," object in this payload and inserts (maps) it into ",(0,i.kt)("inlineCode",{parentName:"p"},"sensorId")," tag in InfluxDB."),(0,i.kt)("p",null,"Apart from extracting data from payloads it's also possible to insert constant values, which may be useful for InfluxDB tags.\nHere is another example which maps a constant value instead of the one taken from an MQTT message:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "sensor-reading",\n            "target": "sensorType",\n            "targetType": "tag",\n            "options": {\n                "isConst": true\n            }\n        }\n    ],\n    ...\n}\n')),(0,i.kt)("p",null,"This extractor maps a constant string (",(0,i.kt)("inlineCode",{parentName:"p"},'"sensor-reading"'),") to the tag ",(0,i.kt)("inlineCode",{parentName:"p"},"sensorType")," in InfluxDB. This means that for every MQTT message for which this mapping is invoked, the tag ",(0,i.kt)("inlineCode",{parentName:"p"},"sensorType")," with value ",(0,i.kt)("inlineCode",{parentName:"p"},'"sensor-reading"')," will be added to the InfluxDB measurement."),(0,i.kt)("p",null,"To insert the entire MQTT payload (useful when the payload is of a primitive type like a string or a number), the extractor would look similar to the following:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload]",\n            "target": "status",\n            "targetType": "field"\n        }\n    ],\n    ...\n}\n')),(0,i.kt)("p",null,"Note that apart from ",(0,i.kt)("inlineCode",{parentName:"p"},"[payload]"),", various special metadata properties of the MQTT message may be selected. Here is the entire list of special (meta)data properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hostname"),": Hostname of the broker. Note that the ",(0,i.kt)("inlineCode",{parentName:"li"},"HOSTNAME")," environment variable must be specified for the broker, or the default value will be used (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),", defaults to: ",(0,i.kt)("inlineCode",{parentName:"li"},"<Unknown>"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"topic"),": Name of the topic to which the MQTT message was published (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"payload"),": Payload of the MQTT message. Can be used to further unpack (pick out) child properties of the payload object if the latter is a JSON. See below for more information. If the payload was originally a string or a number, it will be treated as such, and no typecasting is necessary (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"any"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"qos"),": QoS level of the MQTT message (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),", one of: ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"1"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"2"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"retain")," - Retain flag of the MQTT message (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"timestamp")," - Unix timestamp representing the time when the MQTT message arrived at the broker (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"integer"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"datetime")," - Datetime string representing the time when the MQTT message arrived at the broker (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string")," representing the date in ISO format)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"uuid")," - unique identifier (UUID) of the message. Note that it is a convenience property. This ID is internally generated by the InfluxDB Bridge plugin and is not coming from the original message's metadata (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"client_id")," - client_id of the device that published the MQTT message (type: ",(0,i.kt)("inlineCode",{parentName:"li"},"string"),").")),(0,i.kt)("p",null,"To select one of the above-mentioned properties, it should be enclosed in square brackets (",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),") and specified in the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," field of the configuration file."),(0,i.kt)("p",null,"For example, to use the client ID of the device that published the message as a tag in InfluxDB, the following selector can be defined:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[client_id]",\n            "target": "deviceId",\n            "targetType": "tag"\n        }\n    ],\n    ...\n}\n')),(0,i.kt)("h2",m({},{id:"data-type-casting"}),"Data type casting"),(0,i.kt)("p",null,"InfluxDB Bridge provides a feature to typecast properties of the MQTT messages before they are inserted into measurements."),(0,i.kt)("p",null,"In order to cast a certain property to a certain type, the following configuration must be specified:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "<your mapping name here>",\n    "mapping": [\n        {\n            "source": "<your source mqtt message property>",\n            "target": "<your target influxdb field/tag name>",\n            "targetType": "<field or tag>",\n            "type": "<specify type to cast \'source\' into>"\n        }\n    ],\n    ...\n}\n')),(0,i.kt)("p",null,"For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][temperature_str]",\n            "target": "temperature",\n            "targetType": "field",\n            "type": "float"\n        }\n    ],\n    ...\n}\n')),(0,i.kt)("p",null,"Appropriate type casting depends on whether the target is a field or a tag in InfluxDB:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For tags: Tags are always stored as strings in InfluxDB.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For fields: InfluxDB supports the following field types:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"float")," / ",(0,i.kt)("inlineCode",{parentName:"li"},"double"),": for floating point values"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"integer"),": for integer values"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"string"),": for text values"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"boolean"),": for true/false values")))),(0,i.kt)("p",null,"Keeping the above in mind, in InfluxDB bridge the following typecasting is provided and makes sense:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For tags: Tags are automatically converted to strings from any type. Therefore the only typecasting that makes sense here is a ",(0,i.kt)("inlineCode",{parentName:"p"},"datetime")," if you are using a date as a tag and want to change it's format. See below for more information on ",(0,i.kt)("inlineCode",{parentName:"p"},"datetime")," casting.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For fields:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"datetime"),":  casts integers or strings into a datetime (",(0,i.kt)("inlineCode",{parentName:"li"},"format"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"dbFormat")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"replaceDelimiter")," might need to be specified. See ",(0,i.kt)("a",m({parentName:"li"},{href:"#config-format"}),"config options section")," for details). There is no need to typecast datetime strings if they follow ISO format (note that the timezone portion is not required here since many databases don't handle timezones)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"number"),": casts strings into either a float or integer (supports float numbers separated by both dots or commas (e.g. both ",(0,i.kt)("inlineCode",{parentName:"li"},"1.5")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"1,5")," are handled))."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"integer"),": casts string into an integer truncating the fractional part."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"boolean"),": casts strings or numbers into a boolean value (note that string ",(0,i.kt)("inlineCode",{parentName:"li"},'"false"')," is cast to the ",(0,i.kt)("inlineCode",{parentName:"li"},"false")," boolean value, as is number ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"null"),", empty string, or a missing property. Everything else is cast to ",(0,i.kt)("inlineCode",{parentName:"li"},"true"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"string"),": can cast numbers into strings. There is typically no need to typecast JSON objects to strings as this is done automatically.")))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that while it might be tempting to explicitly specify typecasting for all the ",(0,i.kt)("inlineCode",{parentName:"p"},"source"),"s, this is not recommended as typecasting is often associated with additional overhead. The rule of thumb would be to cast only what is necessary.")),(0,i.kt)("h2",m({},{id:"line-protocol"}),"Line Protocol"),(0,i.kt)("p",null,"InfluxDB natively understands the ",(0,i.kt)("a",m({parentName:"p"},{href:"https://docs.influxdata.com/influxdb/v2.6/reference/syntax/line-protocol/"}),"Line Protocol")," format. If your MQTT payload already contains data in Line Protocol format, you can use the special ",(0,i.kt)("inlineCode",{parentName:"p"},"lineProtocol")," target type to directly insert it:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload]",\n            "target": "",\n            "targetType": "lineProtocol"\n        }\n    ],\n    ...\n}\n')),(0,i.kt)("p",null,"Note that the target is empty. This is because line protocol strings already include all the required data (which measurements, tags, and fields to insert). Apart from setting target of the mapping to an empty string, you will also have to set a ",(0,i.kt)("inlineCode",{parentName:"p"},"target")," field of the ",(0,i.kt)("inlineCode",{parentName:"p"},"topicMappings")," to an empty string. This is again because the name of the measurement has to be included as part of the line protocol string itself."),(0,i.kt)("p",null,"With the configuration above, if your MQTT payload contains valid Line Protocol data like:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{}),"weather,location=us-midwest temperature=82.0,humidity=54 1465839830100400200\n")),(0,i.kt)("p",null,"It will be directly parsed and inserted by InfluxDB."),(0,i.kt)("p",null,"Also note that the timestamp at the end is in nanoseconds. The timestamp may also be omitted, in which case the current time of message reception by the InfluxDB will be used instead."),(0,i.kt)("h2",m({},{id:"extractor-options"}),"Extractor options"),(0,i.kt)("p",null,"Each extractor under the ",(0,i.kt)("inlineCode",{parentName:"p"},"mapping")," section of the configuration file can have additional options that define transformations to be performed on the ",(0,i.kt)("inlineCode",{parentName:"p"},"source")," data before it is inserted into ",(0,i.kt)("inlineCode",{parentName:"p"},"target"),". For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][property1]",\n            "target": "column_a",\n            "options": {\n                "replaceNullWith": "<null>"\n            }\n        }\n    ],\n    ...\n}\n')),(0,i.kt)("p",null,"The above specifies an extractor that maps ",(0,i.kt)("inlineCode",{parentName:"p"},"property1")," of the MQTT message to the ",(0,i.kt)("inlineCode",{parentName:"p"},"column_a")," in the InfluxDB measurement. Once the ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," value is encountered in the ",(0,i.kt)("inlineCode",{parentName:"p"},"property1")," property of the MQTT message's payload, it will be converted to ",(0,i.kt)("inlineCode",{parentName:"p"},'"<null>"')," string before being inserted into the database."),(0,i.kt)("p",null,"Note that some options can only be used with certain (or when typecasting to certain) datatypes, while others can be used with any type."),(0,i.kt)("p",null,"Options which can only be used when typecasting to ",(0,i.kt)("inlineCode",{parentName:"p"},"datetime"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"format")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dbFormat")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replaceDelimiter"))),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][property1]",\n            "target": "column_a",\n            "type": "datetime",\n            "options": {\n                "nullValue": "<null>",\n                "format": "yyyy-MM-dd HH:mm:ss",\n                "dbFormat": "dd-MMM-yy hh:mm:ss",\n                "replaceDelimiter": " "\n            }\n        }\n    ],\n    ...\n}\n')),(0,i.kt)("p",null,"Options which can be used as long as the underlying value is a ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replace"))),(0,i.kt)("p",null,"Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    ...\n    "name": "mapping1",\n    "mapping": [\n        {\n            "source": "[payload][property1]",\n            "target": "column_a",\n            "options": {\n                "replace": ["hello world", "hello SQL"]\n            }\n        }\n    ],\n    ...\n}\n')),(0,i.kt)("p",null,"Options which can be used regardless of types and typecasting:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replaceNullWith")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replaceUndefinedWith")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"isConst"))),(0,i.kt)("p",null,"See ",(0,i.kt)("a",m({parentName:"p"},{href:"#config-format"}),"configuration options")," for more information on the listed options (their descriptions, datatypes, allowed values)."),(0,i.kt)("h2",m({},{id:"choosing-influxdb-version"}),"Choosing InfluxDB version"),(0,i.kt)("p",null,"To work with different InfluxDB versions you have to change the ",(0,i.kt)("inlineCode",{parentName:"p"},"driver")," field under ",(0,i.kt)("inlineCode",{parentName:"p"},"connection")," in a respective connection object of the configuration. The allowed values are ",(0,i.kt)("inlineCode",{parentName:"p"},"influxdbv1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"influxdbv2"),". To work with InfluxDB v3 choose ",(0,i.kt)("inlineCode",{parentName:"p"},"influxdbv2")," driver as the REST API for v2 and v3 is the same."),(0,i.kt)("p",null,"There are also some additional properties specific to the InfluxDB version. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"username")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"password")," properties under ",(0,i.kt)("inlineCode",{parentName:"p"},"credentials")," are only relevant to InfluxDB v1, while ",(0,i.kt)("inlineCode",{parentName:"p"},"token")," property is only used for v2."),(0,i.kt)("p",null,"Apart from that, there is a ",(0,i.kt)("inlineCode",{parentName:"p"},"compression")," object under ",(0,i.kt)("inlineCode",{parentName:"p"},"connection"),", which is applicable only to InfluxDB v2."),(0,i.kt)("h2",m({},{id:"ssl-connection-options"}),"SSL connection options"),(0,i.kt)("p",null,"As InfluxDB (both v1 and v2) supports custom server certificates, you can specify TLS/SSL options under ",(0,i.kt)("inlineCode",{parentName:"p"},"ssl")," field to allow Mosquitto to connect to such an InfluxDB instance."),(0,i.kt)("p",null,"As InfluxDB does not support mTLS you can only specify a CA certificate that signed the custom certificate of your InfluxDB under SSL options. To that end, there are two fields: ",(0,i.kt)("inlineCode",{parentName:"p"},"ca")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"caPath"),". The first one specifies a certificate as a PEM-formatted string, while the other field specifies a path to a certificate file on the filesystem."),(0,i.kt)("p",null,"Another field under SSL options is ",(0,i.kt)("inlineCode",{parentName:"p"},"rejectUnauthorized")," which is a boolean specifying whether to reject unknown certificates. This option must not be specified in production as it opens your connection up to Man-in-the-Middle (MITM) attacks. The default for this setting is ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),"."),(0,i.kt)("p",null,"If instead of custom certificates your InfluxDB instance is using a certificate signed by a well-known certificate authority (one of the CAs whose certificates are shipped together with major browsers like Firefox), you may set the ",(0,i.kt)("inlineCode",{parentName:"p"},"ssl")," field to an empty object. This is the same as specifying an ",(0,i.kt)("inlineCode",{parentName:"p"},"ssl")," object with a single property ",(0,i.kt)("inlineCode",{parentName:"p"},"rejectUnauthorized")," set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". This way a TLS connection will still be initiated by the broker."),(0,i.kt)("h2",m({},{id:"compression"}),"Compression"),(0,i.kt)("p",null,"InfluxDB v2 supports data compression of incoming records with ",(0,i.kt)("inlineCode",{parentName:"p"},"gzip")," as ",(0,i.kt)("a",m({parentName:"p"},{href:"https://docs.influxdata.com/influxdb/v2/write-data/developer-tools/api/#use-gzip-compression-with-the-influxdb-api"}),"noted in the InfluxDB documentation"),"\nCompression in InfluxDB is one of the techniques to ",(0,i.kt)("a",m({parentName:"p"},{href:"https://docs.influxdata.com/influxdb/cloud/write-data/best-practices/optimize-writes/?t=InfluxDB+API#use-gzip-compression"}),"optimize writes to the database"),"\nHowever, be aware that while compression reduces network bandwidth, it increases the load on the server as it has to perform compression every time before sending the data over. This means that careful benchmarking needs to be performed before deciding if compression helps your use case."),(0,i.kt)("p",null,"To enable compression set an ",(0,i.kt)("inlineCode",{parentName:"p"},"enable")," field under ",(0,i.kt)("inlineCode",{parentName:"p"},"compression")," object in ",(0,i.kt)("inlineCode",{parentName:"p"},"connection")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),". The default value is ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),". This feature only works for InfluxDB v2 and higher."),(0,i.kt)("h2",m({},{id:"configuration-example"}),"Configuration example"),(0,i.kt)("p",null,"An example of the configuration with two database connections is shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    "version": "1",\n    "connections": [\n        {\n            "name": "InfluxDB v1 Connection",\n            "connection": {\n                "driver": "influxdbv1",\n                "hostname": "influxdb-v1.example.com",\n                "port": 8086,\n                "database": "mqtt_data",\n                "credentials": {\n                    "username": "admin",\n                    "password": "password123"\n                }\n            },\n            "options": {\n                "bufferSize": 5000,\n                "timeoutMs": 3000,\n                "queueMaxSize": 10000,\n                "maxRetries": 15,\n                "retryDelayMs": 1000\n            },\n            "topicMappings": [\n                {\n                    "name": "topic-mapping-to-weather-measurement",\n                    "schemaMapping": "weather-schema-mapping",\n                    "target": "weather_data",\n                    "mqttTopics": [\n                        "sensors/weather/#"\n                    ]\n                }\n            ]\n        },\n        {\n            "name": "InfluxDB v2 Connection",\n            "connection": {\n                "driver": "influxdbv2",\n                "hostname": "influxdb-v2.example.com",\n                "port": 8086,\n                "database": "mqtt_metrics",\n                "organization": "my-org",\n                "credentials": {\n                    "token": "your-influxdb-v2-token"\n                },\n                "compression": {\n                    "enable": true\n                }\n            },\n            "options": {\n                "bufferSize": 1000,\n                "timeoutMs": 4000,\n                "queueMaxSize": 5000,\n                "maxRetries": 10,\n                "retryDelayMs": 2000\n            },\n            "topicMappings": [\n                {\n                    "name": "topic-mapping-to-system-measurement",\n                    "schemaMapping": "system-schema-mapping",\n                    "target": "system_metrics",\n                    "mqttTopics": [\n                        "system/metrics/#"\n                    ]\n                }\n            ]\n        }\n    ],\n    "schemaMappings": [\n        {\n            "name": "weather-schema-mapping",\n            "mapping": [\n                {\n                    "source": "[client_id]",\n                    "target": "device_id",\n                    "targetType": "tag"\n                },\n                {\n                    "source": "[payload][temperature]",\n                    "target": "temperature",\n                    "targetType": "field"\n                },\n                {\n                    "source": "[payload][humidity]",\n                    "target": "humidity",\n                    "targetType": "field"\n                },\n                {\n                    "source": "[payload][location]",\n                    "target": "location",\n                    "targetType": "tag"\n                },\n                {\n                    "source": "[timestamp]",\n                    "target": "recorded_at",\n                    "targetType": "field"\n                }\n            ]\n        },\n        {\n            "name": "system-schema-mapping",\n            "mapping": [\n                {\n                    "source": "[client_id]",\n                    "target": "host",\n                    "targetType": "tag"\n                },\n                {\n                    "source": "[payload][cpu]",\n                    "target": "cpu_usage",\n                    "targetType": "field"\n                },\n                {\n                    "source": "[payload][memory]",\n                    "target": "memory_usage",\n                    "targetType": "field"\n                },\n                {\n                    "source": "[payload][disk]",\n                    "target": "disk_usage",\n                    "targetType": "field"\n                },\n                {\n                    "source": "system",\n                    "target": "data_type",\n                    "targetType": "tag",\n                    "options": {\n                        "isConst": true\n                    }\n                }\n            ]\n        }\n    ]\n}\n')),(0,i.kt)("p",null,"As per the example config above, InfluxDB bridge will connect to two databases: an InfluxDB v1 instance at ",(0,i.kt)("inlineCode",{parentName:"p"},"influxdb-v1.example.com:8086")," and an InfluxDB v2 instance at ",(0,i.kt)("inlineCode",{parentName:"p"},"influxdb-v2.example.com:8086"),". It will use a database called ",(0,i.kt)("inlineCode",{parentName:"p"},"mqtt_data")," for v1 and a bucket called ",(0,i.kt)("inlineCode",{parentName:"p"},"mqtt_metrics")," in the organization ",(0,i.kt)("inlineCode",{parentName:"p"},"my-org")," for v2."),(0,i.kt)("p",null,"The optional ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," field is specified and overrides some defaults of the plugin's buffering. For the v1 connection, it sets ",(0,i.kt)("inlineCode",{parentName:"p"},"bufferSize")," to 5000 and ",(0,i.kt)("inlineCode",{parentName:"p"},"timeoutMs")," to 3000 milliseconds, while for the v2 connection, it sets ",(0,i.kt)("inlineCode",{parentName:"p"},"bufferSize")," to 1000 and ",(0,i.kt)("inlineCode",{parentName:"p"},"timeoutMs")," to 4000 milliseconds. This illustrates that you can set different queue options per database connection, making it adjustable to different traffic loads."),(0,i.kt)("p",null,"Also see ",(0,i.kt)("a",m({parentName:"p"},{href:"#buffering"}),"section about buffering")," for more information."),(0,i.kt)("p",null,"The retry queue parameters are in this case also configured differently depending on the database connection. See ",(0,i.kt)("a",m({parentName:"p"},{href:"#retry-queue"}),"section about retry queue")," for more information."),(0,i.kt)("p",null,"Notice that InfluxDB v2 connection has ",(0,i.kt)("inlineCode",{parentName:"p"},"compression")," enabled, which will compress data before sending it to the database, reducing bandwidth at the cost of increased server load. This option is only available for InfluxDB v2."),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"topicMappings")," section, we define which MQTT topics should be forwarded to which InfluxDB measurements. The v1 connection maps topics matching ",(0,i.kt)("inlineCode",{parentName:"p"},"sensors/weather/#")," to the ",(0,i.kt)("inlineCode",{parentName:"p"},"weather_data")," measurement, while the v2 connection maps topics matching ",(0,i.kt)("inlineCode",{parentName:"p"},"system/metrics/#")," to the measurement called ",(0,i.kt)("inlineCode",{parentName:"p"},"system_metrics"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"schemaMappings")," section defines how the MQTT message data should be mapped to InfluxDB fields and tags. For example, in the ",(0,i.kt)("inlineCode",{parentName:"p"},"weather-schema-mapping"),", we extract:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The client ID as a tag called ",(0,i.kt)("inlineCode",{parentName:"li"},"device_id")),(0,i.kt)("li",{parentName:"ul"},"The temperature, humidity, and timestamp from the payload as fields"),(0,i.kt)("li",{parentName:"ul"},"The location from the payload as a tag")),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"system-schema-mapping"),", we extract:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The client ID as a tag called ",(0,i.kt)("inlineCode",{parentName:"li"},"host")),(0,i.kt)("li",{parentName:"ul"},"CPU, memory, and disk usage from the payload as fields"),(0,i.kt)("li",{parentName:"ul"},"We also add a constant tag called ",(0,i.kt)("inlineCode",{parentName:"li"},"data_type")," with the value ",(0,i.kt)("inlineCode",{parentName:"li"},"system"),". This value will stay the same for all records")),(0,i.kt)("h2",m({},{id:"error-handling"}),"Error handling"),(0,i.kt)("p",null,"Any configuration or license errors will prevent the plugin from being loaded, and respective messages will appear in stderr and stdout."),(0,i.kt)("p",null,"If recoverable errors occur during the operation of the plugin, it will generate respective error messages in its stderr and prefix them with an ",(0,i.kt)("inlineCode",{parentName:"p"},"ERR:")," prefix. This includes: encountering errors when converting MQTT messages to InfluxDB format as well as failures during data insertion."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that while error messages generated by the plugin will be preceded by ",(0,i.kt)("inlineCode",{parentName:"p"},"ERR:"),", warning messages will get a ",(0,i.kt)("inlineCode",{parentName:"p"},"WARN:")," prefix, while debug messages - a respective ",(0,i.kt)("inlineCode",{parentName:"p"},"DEBUG:"),".")),(0,i.kt)("h2",m({},{id:"debugging"}),"Debugging"),(0,i.kt)("p",null,"To print detailed information about operations being performed against the InfluxDB database to the stdout, define the ",(0,i.kt)("inlineCode",{parentName:"p"},"DEBUG")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"DEBUG_INFLUXDB_BRIDGE")," environment variables on the broker."),(0,i.kt)("p",null,"In future versions the functionality of debug environment variables will move to the ",(0,i.kt)("inlineCode",{parentName:"p"},"debug")," property in the configuration file under ",(0,i.kt)("inlineCode",{parentName:"p"},"connection")," section."),(0,i.kt)("h2",m({},{id:"notes-on-data-insertions-and-data-format"}),"Notes on data insertions and data format"),(0,i.kt)("p",null,"Under the hood the plugin converts all the data to InfluxDB line protocol records, which are then inserted using InfluxDB REST API endpoint.\nWhile converting data to line protocol, InfluxDB bridge takes care of escaping spaces and special characters in measurement names and field names, so you don't have to worry about escaping when writing plugin's configuration."),(0,i.kt)("h2",m({},{id:"buffering"}),"Buffering"),(0,i.kt)("p",null,"Buffers are created per measurement for every InfluxDB connection. The size of the buffer is controlled with ",(0,i.kt)("inlineCode",{parentName:"p"},"bufferSize")," field under ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," (",(0,i.kt)("inlineCode",{parentName:"p"},"$.connections[].options"),") and indicates the capacity of the buffer. The default size of the buffer is 1000. Buffer holds records representing unpacked MQTT messages (or line protocol strings if this is the configured format of your MQTT messages) which are to be inserted to the respective measurement once the buffer is saturated."),(0,i.kt)("p",null,"Once the buffer fills up, its flushing is triggered, and a batch write is issued against the measurement, inserting the buffer contents. The condition for buffer flush is ",(0,i.kt)("inlineCode",{parentName:"p"},"bufferSize + 1"),". Once this number of records is reached, the buffer is released."),(0,i.kt)("p",null,"Another parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"timeoutMs")," - indicates the time interval (in milliseconds) after which all the non-empty buffers will be forcefully released triggering the batch writes of the buffers' contents. The default value is 5000 ms."),(0,i.kt)("p",null,"However, even though it might seem that buffer is only released after saturation or a timeout, it also has a mechanism to account for infrequent MQTT messages and decrease the latency of database inserts for such records."),(0,i.kt)("p",null,'The idea is that the time interval between consecutive MQTT messages is kept track of. If this interval is long enough, the record will be inserted instantly. However, if the interval between the messages is short, the plugin will keep buffering the messages anticipating a possible influx. The definition of "long enough" might change when updates to the plugin are made, but currently, it\'s a fraction of the ',(0,i.kt)("inlineCode",{parentName:"p"},"timeoutMs.")),(0,i.kt)("p",null,"Note that this leads to the first MQTT message never being buffered."),(0,i.kt)("p",null,"Also, notice that buffer options can be defined per database connection, allowing for more flexibility and fine-tuning when needed."),(0,i.kt)("h2",m({},{id:"retry-queue"}),"Retry queue"),(0,i.kt)("p",null,"The InfluxDB bridge plugin provides a retry mechanism for failed writes to ensure data is not lost in case of temporary connection issues. To prevent data loss, InfluxDB bridge has a retry queue that is responsible for retrying message writes in case of connection problems."),(0,i.kt)("p",null,"Each retry queue can be configured with the following settings (under ",(0,i.kt)("inlineCode",{parentName:"p"},"options")," field of the configuration (",(0,i.kt)("inlineCode",{parentName:"p"},"$.connections[].options"),")):"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"queueMaxSize")," option is used to set the maximum amount of messages that the queue is able to accommodate before it starts to drop them. This limit can be set to infinity using the value ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),", which is the default. Note that if this value is not set to ",(0,i.kt)("inlineCode",{parentName:"p"},"-1"),", then careful considerations and testing should be performed to ensure that the queue will not overfill too quickly."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"maxRetries")," is used to specify the maximum number of retry attempts the queue will make before dropping a message. The default is 10."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"retryDelayMs")," is a minimum amount of time in milliseconds that must pass between the retry queue attempts. The default is 1000 ms (1 second)."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note that the elements in a retry queue can be both single MQTT messages as well as entire buffers of MQTT messages that are ready to be batch-written to InfluxDB.")),(0,i.kt)("p",null,"An important point is that retries happen only in case of connection errors. In case of invalid data the error is logged out but no retries are performed. If a batch of messages is being inserted and only some of these messages are invalid, then the filtering of invalid records from valid ones will happen on the side of the InfluxDB itself using its native mechanisms to handle invalid data."),(0,i.kt)("h2",m({},{id:"json-schema"}),"JSON schema"),(0,i.kt)("p",null,"InfluxDB bridge plugin uses the following JSON schema for its configuration:"),(0,i.kt)("pre",null,(0,i.kt)("code",m({parentName:"pre"},{className:"language-json"}),'{\n    "title": "InfluxDB-Bridge Plugin Config",\n    "type": "object",\n    "properties": {\n        "version": {\n            "type": ["string", "integer"],\n            "nullable": true,\n            "description": "Version of the configuration file"\n        },\n        "connections": {\n            "type": "array",\n            "description": "List of sub-configurations per InfluxDB connection",\n            "items": {\n                "type": "object",\n                "description": "Configuration per InfluxDB connection",\n                "properties": {\n                    "name": {\n                        "type": "string",\n                        "nullable": false,\n                        "description": "Unique textual identifier of the configuration"\n                    },\n                    "connection": {\n                        "type": "object",\n                        "description": "InfluxDB connection specific configuration",\n                        "properties": {\n                            "driver": {\n                                "type": "string",\n                                "enum": ["influxdbv1", "influxdbv2"],\n                                "nullable": false,\n                                "description": "Name of the InfluxDB driver to use (for InfluxDB v1 or InfluxDB v2/v3)"\n                            },\n                            "hostname": {\n                                "type": "string",\n                                "nullable": false,\n                                "description": "Hostname or IP of the InfluxDB server to connect to"\n                            },\n                            "port": {\n                                "type": "integer",\n                                "nullable": false,\n                                "description": "Port of the InfluxDB server to connect to"\n                            },\n                            "database": {\n                                "type": "string",\n                                "nullable": false,\n                                "description": "Name of the database (or bucket for influxdb v2) to connect to"\n                            },\n                            "organization": {\n                                "type": "string",\n                                "nullable": true,\n                                "description": "Organization that a bucket belongs to in InfluxDB v2"\n                            },\n                            "compression": {\n                                "type": "object",\n                                "nullable": true,\n                                "description": "Properties related to data compression happening before sending it over to InfluxDB",\n                                "properties": {\n                                    "enable": {\n                                        "type": "boolean",\n                                        "nullable": true,\n                                        "default": false,\n                                        "description": "Whether to compress data before influxdb. Less bandwidth required but inflicts more strain on the server"\n                                    }\n                                }\n                            },\n                            "credentials": {\n                                "type": "object",\n                                "nullable": false,\n                                "description": "Credentials to authenticate to InfluxDB. Combine both v1 credentials (username and password) and v2 credentials (tokens). Only one of the two which corresponds to the InfluxDB version in use must be selected",\n                                "properties": {\n                                    "token": {\n                                        "type": "string",\n                                        "nullable": true,\n                                        "description": "Authentication token for InfluxDB v2 connection"\n                                    },\n                                    "username": {\n                                        "type": "string",\n                                        "nullable": true,\n                                        "description": "Username for InfluxDB v1"\n                                    },\n                                    "password": {\n                                        "type": "string",\n                                        "nullable": true,\n                                        "description": "Password for InfluxDB v1"\n                                    }\n                                }\n                            },\n                            "ssl": {\n                                "type": "object",\n                                "nullable": true,\n                                "description": "SSL configuration for the connection",\n                                "properties": {\n                                    "ca": {\n                                        "type": "string",\n                                        "nullable": true,\n                                        "description": "CA certificate file to use for the connection"\n                                    },\n                                    "caPath": {\n                                        "type": "string",\n                                        "nullable": true,\n                                        "description": "CA certificate path to use for the connection"\n                                    },\n                                    "rejectUnauthorized": {\n                                        "type": "boolean",\n                                        "nullable": true,\n                                        "description": "Whether to reject unauthorized connections or not"\n                                    }\n                                }\n                            },\n                            "debug": {\n                                "type": "boolean",\n                                "nullable": true,\n                                "description": "Whether to enable debug query logging for connection"\n                            },\n                            "lazyConnect": {\n                                "type": "boolean",\n                                "nullable": true,\n                                "default": false,\n                                "description": "Whether to allow the plugin to continue if the connection to the database cannot be established"\n                            }\n                        },\n                        "nullable": false,\n                        "required": [\n                            "driver"\n                        ]\n                    },\n                    "topicMappings": {\n                        "type": "array",\n                        "description": "List of topic mapping objects to forward MQTT messages to InfluxDB",\n                        "items": {\n                            "type": "object",\n                            "properties": {\n                                "name": {\n                                    "type": "string",\n                                    "nullable": false,\n                                    "description": "Unique identifier of this mapping"\n                                },\n                                "schemaMapping": {\n                                    "type": "string",\n                                    "nullable": false,\n                                    "description": "Name of the schema mapping which should be applied here"\n                                },\n                                "target": {\n                                    "type": "string",\n                                    "description": "InfluxDB measurement to forward MQTT messages to"\n                                },\n                                "options": {\n                                    "type": "object",\n                                    "nullable": true,\n                                    "description": "Optional options for the measurement"\n                                },\n                                "mqttTopics": {\n                                    "type": "array",\n                                    "items": {\n                                        "type": "string",\n                                        "description": "List of MQTT topics to forward messages from",\n                                        "pattern": "^((\\\\+?|[\\\\w-]+)((\\\\/[\\\\w-]+)?(\\\\/\\\\+)?(\\\\/[\\\\w-]+)?((?<!\\\\+)\\\\/)?)*(\\\\/#)?|(\\\\/)?#)$"\n                                    }\n                                }\n                            },\n                            "required": ["name", "target", "mqttTopics"]\n                        }\n                    },\n                    "options": {\n                        "type": "object",\n                        "nullable": true,\n                        "description": "Plugin options for configuring internal queues and buffers",\n                        "properties": {\n                            "bufferSize": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 1,\n                                "description": "Maximum number of messages to buffer before flushing to the database"\n                            },\n                            "timeoutMs": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 0,\n                                "description": "Maximum time in milliseconds to buffer messages before flushing to the database"\n                            },\n                            "queueMaxSize": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": -1,\n                                "description": "Maximum number of messages in retry queue"\n                            },\n                            "maxRetries": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 0,\n                                "description": "Maximum number of retries for failed inserts due to lost connection"\n                            },\n                            "retryDelayMs": {\n                                "type": "integer",\n                                "nullable": true,\n                                "minimum": 0,\n                                "description": "Delay in milliseconds before retrying inserts failed due to lost connection"\n                            }\n                        }\n                    }\n                },\n                "required": ["name", "connection", "topicMappings"]\n            }\n        },\n        "schemaMappings": {\n            "type": "array",\n            "items": {\n                "type": "object",\n                "properties": {\n                    "name": {\n                        "type": "string",\n                        "nullable": false,\n                        "description": "Unique identifier of the mapping"\n                    },\n                    "mapping": {\n                        "type": "array",\n                        "description": "List of mappings to apply to InfluxDB. Each schema contains a mapping of InfluxDB fields/tags to MQTT message properties",\n                        "items": {\n                            "type": "object",\n                            "description": "Properties to select from the MQTT message and insert into InfluxDB",\n                            "properties": {\n                                "source": {\n                                    "oneOf": [\n                                        { "type": "string" },\n                                        { "type": "number" },\n                                        { "type": "null", "nullable": true }\n                                    ],\n                                    "description": "JSON path to the value to insert or constant value"\n                                },\n                                "target": {\n                                    "type": "string",\n                                    "description": "Name of the field or tag to insert data from \\"source\\" into"\n                                },\n                                "targetType": {\n                                    "type": "string",\n                                    "enum": ["tag", "field", "lineProtocol"],\n                                    "description": "Whether the target is a tag or a field in InfluxDB"\n                                },\n                                "type": {\n                                    "type": "string",\n                                    "nullable": true,\n                                    "description": "Data type of the value to cast source to before inserting"\n                                },\n                                "options": {\n                                    "type": "object",\n                                    "nullable": true,\n                                    "description": "Optional options for the field or tag",\n                                    "properties": {\n                                        "isConst": {\n                                            "type": "boolean",\n                                            "nullable": true,\n                                            "description": "Whether the source is a constant value"\n                                        }\n                                    }\n                                }\n                            },\n                            "required": ["source", "target", "targetType"]\n                        }\n                    }\n                },\n                "required": ["name", "mapping"]\n            }\n        }\n    },\n    "required": ["connections", "schemaMappings"]\n}\n')))}b.isMDXComponent=!0}}]);